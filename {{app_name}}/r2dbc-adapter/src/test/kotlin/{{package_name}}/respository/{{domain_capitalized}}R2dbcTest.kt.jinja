package {{package_name}}.respository

import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.MethodOrderer.OrderAnnotation
import org.junit.jupiter.api.Order
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.TestMethodOrder
import org.junit.jupiter.api.extension.ExtendWith
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.r2dbc.core.DatabaseClient
import org.springframework.test.context.ActiveProfiles
import org.springframework.test.context.junit.jupiter.SpringExtension
import {{package_name}}.domain.port.Obtain{{domain_capitalized}}
import reactor.test.StepVerifier
import java.util.function.Consumer


@SpringBootTest
@ExtendWith(SpringExtension::class)
@TestMethodOrder(OrderAnnotation::class)
@ActiveProfiles("test")
class {{domain_capitalized}}R2dbcTest {

  @Autowired
  lateinit var client: DatabaseClient

  @Autowired
  lateinit var obtain{{domain_capitalized}}: Obtain{{domain_capitalized}}

  @Test
  fun `should be able to boot`() {
    assertThat(true).isTrue
  }

  @Test
  fun `given {{domain_plural}} exists in database when asked for {{domain_plural}} from database should return all {{domain_plural}}`() {
    // Given
    delete{{domain_capitalized}}Data()
    loadSample{{domain_capitalized}}Data()
    // When & Then
    obtain{{domain_capitalized}}.getAll{{domain_plural_capitalized}}().`as`(StepVerifier::create).expectNextMatches {
      assertThat(it.description).isEqualTo("Twinkle twinkle little star")
      true
    }.verifyComplete()
  }

  @Test
  fun `given no {{domain_plural}} exists in database when asked for {{domain_plural}} should return empty`() {
    // Given
    delete{{domain_capitalized}}Data()
    // When & Then
    obtain{{domain_capitalized}}.getAll{{domain_plural_capitalized}}().`as`(StepVerifier::create).verifyComplete()
  }

  @Test
  @Order(1) // we need this order because of the auto-increment
  fun `given {{domain_plural}} exists in database when asked for {{domain}} by id should return the {{domain}}`() {
    // Given
    delete{{domain_capitalized}}Data()
    loadSample{{domain_capitalized}}Data()
    // When & Then
    obtain{{domain_capitalized}}.get{{domain_capitalized}}ByCode(1).`as`(StepVerifier::create).expectNextMatches {
      assertThat(it.description).isEqualTo("Twinkle twinkle little star")
      true
    }.verifyComplete()
  }

  @Test
  fun `given {{domain_plural}} exists in database when asked for {{domain}} by id that does not exists should empty`() {
    // Given
    delete{{domain_capitalized}}Data()
    loadSample{{domain_capitalized}}Data()
    // When & Then
    obtain{{domain_capitalized}}.get{{domain_capitalized}}ByCode(-1).`as`(StepVerifier::create).expectNextCount(0)
      .verifyComplete()
  }

  private fun loadSample{{domain_capitalized}}Data() {
    val statements: List<String> = listOf(
      "INSERT INTO {{domain_uppercase}}.T_{{domain_uppercase}}(CODE,DESCRIPTION) VALUES(1, 'Twinkle twinkle little star');",
    )

    statements.forEach(Consumer { it: String ->
      client.sql(it).fetch().rowsUpdated().`as`(StepVerifier::create).expectNextCount(1)
        .verifyComplete()
    })
  }

  private fun delete{{domain_capitalized}}Data() {
    val statements: List<String> = listOf(
      "DELETE FROM {{domain_uppercase}}.T_{{domain_uppercase}}",
    )

    statements.forEach(Consumer { it: String ->
      client.sql(it).fetch().rowsUpdated().`as`(StepVerifier::create).expectNextCount(1)
        .verifyComplete()
    })
  }
}